<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Parallel Implementation of Prefix Sum" /><meta property="og:locale" content="en" /><meta name="description" content="For a while, I have been invested in learning how to parallelize certain algorithms. Parallelizing algorithms and code in general can be tricky. I have discovered that it is quite tricky. It is surprisingly easy to create race conditions, and race conditions could go unnoticed for a long time or deliver unreliable outputs." /><meta property="og:description" content="For a while, I have been invested in learning how to parallelize certain algorithms. Parallelizing algorithms and code in general can be tricky. I have discovered that it is quite tricky. It is surprisingly easy to create race conditions, and race conditions could go unnoticed for a long time or deliver unreliable outputs." /><link rel="canonical" href="https://khurd21.github.io/posts/cpp-parallel-prefix-sum/" /><meta property="og:url" content="https://khurd21.github.io/posts/cpp-parallel-prefix-sum/" /><meta property="og:site_name" content="Kyle Hurd" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-03-02T00:00:00+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Parallel Implementation of Prefix Sum" /><meta name="twitter:site" content="@twitter_username" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-03-02T17:00:00+00:00","datePublished":"2023-03-02T00:00:00+00:00","description":"For a while, I have been invested in learning how to parallelize certain algorithms. Parallelizing algorithms and code in general can be tricky. I have discovered that it is quite tricky. It is surprisingly easy to create race conditions, and race conditions could go unnoticed for a long time or deliver unreliable outputs.","headline":"Parallel Implementation of Prefix Sum","mainEntityOfPage":{"@type":"WebPage","@id":"https://khurd21.github.io/posts/cpp-parallel-prefix-sum/"},"url":"https://khurd21.github.io/posts/cpp-parallel-prefix-sum/"}</script><title>Parallel Implementation of Prefix Sum | Kyle Hurd</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Kyle Hurd"><meta name="application-name" content="Kyle Hurd"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/img/kyle-hurd-close-up.jpeg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Kyle Hurd</a></div><div class="site-subtitle font-italic">Programmer | WSU | Fall 2022</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a><li class="nav-item"> <a href="/resume/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>RESUME</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/khurd21" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://www.linkedin.com/in/kyle-hurd-ab8168252/" aria-label="linkedin" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['kyle.hurd','wsu.edu'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="https://soundcloud.com/kyle-hurd-3" aria-label="soundcloud" target="_blank" rel="noopener"> <i class="fas fa-music"></i> </a> <a href="" aria-label="" target="_blank" rel="noopener"> <i class=""></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Parallel Implementation of Prefix Sum</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>Parallel Implementation of Prefix Sum</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1677715200" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Mar 2, 2023 </em> </span> <span> Updated <em class="" data-ts="1677776400" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Mar 2, 2023 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://github.com/khurd21">Kyle Hurd</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1442 words"> <em>8 min</em> read</span></div></div></div><div class="post-content"><p>For a while, I have been invested in learning how to parallelize certain algorithms. Parallelizing algorithms and code in general can be tricky. I have discovered that it is quite tricky. It is surprisingly easy to create race conditions, and race conditions could go unnoticed for a long time or deliver unreliable outputs.</p><h2 id="prefix-sum---serial"><span class="mr-2">Prefix Sum - Serial</span><a href="#prefix-sum---serial" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>I was grinding LeetCode questions and Project Euler questions when I came across a problem that required the use of a prefix sum. A prefix sum looks like the following example:</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>a <span class="o">=</span> <span class="o">[</span> a0, a1, a2, a3 <span class="o">]</span>
p <span class="o">=</span> <span class="o">[</span> a0, a0 + a1, a0 + a1 + a2 <span class="o">]</span>

p_n <span class="o">=</span> a0 + a1 + ... + an
<span class="c"># OR</span>
p_n <span class="o">=</span> p_n-1 + an
</pre></table></code></div></div><p>Prefix sum is the running total of all numbers that occurred before it. It carries a dependency on the previous elements being calculated before future values can be calculated. Here is a serial implementation. Timing the program with an array of size 100’000’000, it only takes around a second to complete. In fact, generating the random array took about 7x longer to populate.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;random&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;boost/timer/timer.hpp&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="n">boost</span><span class="o">::</span><span class="n">timer</span><span class="o">::</span><span class="n">auto_cpu_timer</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">prefix_sum_serial</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">input</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">auto_cpu_timer</span> <span class="n">t</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">{};</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">input</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">input</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">input</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">generate_random_array</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="n">lo</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span> <span class="n">hi</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">auto_cpu_timer</span> <span class="n">t</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">random_device</span> <span class="n">random_device</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">mt19937</span> <span class="n">random_engine</span><span class="p">(</span><span class="n">random_device</span><span class="p">());</span>
    <span class="n">std</span><span class="o">::</span><span class="n">uniform_int_distribution</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">distribution</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">numbers</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numbers</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">distribution</span><span class="p">(</span><span class="n">random_engine</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">numbers</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">auto_cpu_timer</span> <span class="n">t</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">lo</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">hi</span><span class="p">(</span><span class="mi">999</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">size</span><span class="p">(</span><span class="mi">100'000'000</span><span class="p">);</span>

    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="n">input_array</span><span class="p">{</span> <span class="n">generate_random_array</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span> <span class="p">};</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="n">serial</span><span class="p">{</span> <span class="n">prefix_sum_serial</span><span class="p">(</span><span class="n">input_array</span><span class="p">)</span> <span class="p">};</span>
<span class="p">}</span>
</pre></table></code></div></div><p>The timer shows that the <code class="language-plaintext highlighter-rouge">prefix_sum_serial</code> function finished executing in around 1 second, whereas the <code class="language-plaintext highlighter-rouge">main</code> function took around 7 seconds to complete. Generating the array of random elements took around 4.7 seconds.</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>❯ /Users/kylehurd/Workplace/tmp/build/tmp
 4.705747s wall, 4.560000s user + 0.130000s system <span class="o">=</span> 4.690000s CPU <span class="o">(</span>99.7%<span class="o">)</span>
 1.107477s wall, 1.030000s user + 0.080000s system <span class="o">=</span> 1.110000s CPU <span class="o">(</span>100.2%<span class="o">)</span>
 6.956303s wall, 6.720000s user + 0.230000s system <span class="o">=</span> 6.950000s CPU <span class="o">(</span>99.9%<span class="o">)</span>
</pre></table></code></div></div><h2 id="generate-array-of-random-numbers---parallel"><span class="mr-2">Generate Array of Random Numbers - Parallel</span><a href="#generate-array-of-random-numbers---parallel" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Given this information, parallelizing the prefix sum right now would not yield a large improvement due to the <code class="language-plaintext highlighter-rouge">generate_random_array</code> function taking the majority of the runtime. My initial thought was to simply parallelize the for loop in the random array generation function. This actually decrease performance by about 0.2 seconds. I attempted to increase/decrease the block size, make the scheduling dynamic, but all attempts yielded a similar performance. I could not understand why this was occurring, but my guess was the distribution method in C++ either didn’t support parallel functionality or the compiler could not figure out a way to parallelize the code.</p><p>I designed this function to replace the serial version. It uses the simple <code class="language-plaintext highlighter-rouge">std::srand</code> function and performs much faster.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">generate_random_array_parallel</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="n">lo</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span> <span class="n">hi</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">auto_cpu_timer</span> <span class="n">t</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">srand</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">time</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">));</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">numbers</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>

    <span class="cp">#pragma omp parallel for
</span>    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numbers</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">lo</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="n">hi</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">numbers</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Generating an array of random elements now completes in under a second. Do note that the line <code class="language-plaintext highlighter-rouge">std::srand(std::time(nullptr))</code> should exist in main. Also, although I am using this for my needs to showcase the prefix sum, I would prefer to find a way to speed up or improve the first implementation of this function. I am not convinced that this implementation is thread-safe, and believe to make things more random, especially across threads, it may be necessary to have an engine per thread and not share them.</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>❯ /Users/kylehurd/Workplace/tmp/build/tmp
 0.728291s wall, 1.780000s user + 0.090000s system <span class="o">=</span> 1.870000s CPU <span class="o">(</span>256.8%<span class="o">)</span>
</pre></table></code></div></div><h3 id="final-implementation"><span class="mr-2">Final Implementation</span><a href="#final-implementation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>In my final attempt at generating a more proper parallel version, I came up with the below implementation. Since there isn’t really a way to guarantee the engine is thread safe, I opted to create an engine for each thread. It is almost twice as slow as the previous idea, but I believe this one is actually thread-safe, and is more C++-like. Now onto the actual prefix sum!</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">generate_random_array_parallel</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="n">lo</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span> <span class="n">hi</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">auto_cpu_timer</span> <span class="n">t</span><span class="p">;</span>

    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">random_device</span> <span class="n">random_device</span><span class="p">;</span>
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mt19937</span><span class="o">&gt;</span> <span class="n">engines</span><span class="p">(</span><span class="n">omp_get_max_threads</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">mt19937</span><span class="p">(</span><span class="n">random_device</span><span class="p">()));</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">numbers</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>

    <span class="cp">#pragma omp parallel
</span>    <span class="p">{</span>
        <span class="k">const</span> <span class="kt">int</span> <span class="n">thread_num</span><span class="p">{</span> <span class="n">omp_get_thread_num</span><span class="p">()</span> <span class="p">};</span>
        <span class="n">std</span><span class="o">::</span><span class="n">uniform_int_distribution</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">distribution</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">);</span>

        <span class="cp">#pragma omp for
</span>        <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numbers</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">distribution</span><span class="p">(</span><span class="n">engines</span><span class="p">[</span><span class="n">thread_num</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">numbers</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="prefix-sum---parallel"><span class="mr-2">Prefix Sum - Parallel</span><a href="#prefix-sum---parallel" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>The parallel version of the prefix sum consists of two passes called an <code class="language-plaintext highlighter-rouge">upsweep</code> and a <code class="language-plaintext highlighter-rouge">downsweep</code>.</p><h3 id="up-sweep"><span class="mr-2">Up Sweep</span><a href="#up-sweep" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>In the up sweep portion, it is needed to build a binary tree such that:</p><ul><li>The root is a sum between [x,y)<li>If a node has a sum [lo,hi) and hi &gt; lo<ul><li>Left child sum is [lo, middle)<li>Right child sum is [middle, hi)<li>A leaf has a sum of [i, i + 1)</ul></ul><p>This approach is known as <code class="language-plaintext highlighter-rouge">divide and conquer</code>. It can be constructed in a parallel fashion.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">upsweep_parallel</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;&amp;</span> <span class="n">tree</span><span class="p">)</span> <span class="p">{</span>

    <span class="cp">#pragma omp parallel for
</span>    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">input</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">input</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="n">tree</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">h</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">const</span> <span class="kt">int</span> <span class="n">i_end</span><span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">h</span><span class="p">));</span>

        <span class="cp">#pragma omp parallel for
</span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">i_end</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">tree</span><span class="p">[</span><span class="n">h</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">h</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">tree</span><span class="p">[</span><span class="n">h</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="down-sweep"><span class="mr-2">Down Sweep</span><a href="#down-sweep" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>The down sweep is another <code class="language-plaintext highlighter-rouge">divide and conquer</code> approach and is relatively straightforward to parallelize.</p><ul><li>Root is given a left value of 0<li>Given a left value<ul><li>Pass the left child the left value of the current node<li>Pass the right child the left value of the current node <strong>plus</strong> the left child’s sum</ul><li>For a given position <code class="language-plaintext highlighter-rouge">i</code><ul><li>output[i] = left + input[i]</ul></ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">downsweep_parallel</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;&amp;</span> <span class="n">tree1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;&amp;</span> <span class="n">tree2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">tree2</span><span class="p">[</span><span class="n">tree2</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="n">tree1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span> <span class="n">h</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">h</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">const</span> <span class="kt">int</span> <span class="n">i_end</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ceil</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">/</span> <span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">h</span><span class="p">)));</span>

        <span class="cp">#pragma omp parallel for
</span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">i_end</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">tree2</span><span class="p">[</span><span class="n">h</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span>
                <span class="n">tree2</span><span class="p">[</span><span class="n">h</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">:</span>
                    <span class="n">tree2</span><span class="p">[</span><span class="n">h</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">tree1</span><span class="p">[</span><span class="n">h</span><span class="p">][</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">input</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">input</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">tree2</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="combine-up-sweep-and-down-sweep"><span class="mr-2">Combine Up Sweep and Down Sweep</span><a href="#combine-up-sweep-and-down-sweep" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>The result is this:</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">prefix_sum_parallel</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">input</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">auto_cpu_timer</span> <span class="n">t</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">{};</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">size_of_trees</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">ceil</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">log</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">/</span> <span class="n">std</span><span class="o">::</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">))));</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">tree1</span><span class="p">(</span><span class="n">size_of_trees</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">size</span><span class="p">()));</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">tree2</span><span class="p">(</span><span class="n">size_of_trees</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">size</span><span class="p">()));</span>

    <span class="n">upsweep_parallel</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="n">tree1</span><span class="p">);</span>
    <span class="n">downsweep_parallel</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">tree1</span><span class="p">,</span> <span class="n">tree2</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="conclusion"><span class="mr-2">Conclusion</span><a href="#conclusion" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>The primary limitation to this design is memory. The larger the array, the more memory is required. Which almost defeats the purpose of parallelizing the algorithm. The reality is, at a certain point, memory and overhead gets in the way, making the parallel version no faster than the serial version. But it is a fun exercise to bang your head on for days. I sure had fun!</p><p>In my eyes, I do not see much benefit from the parallel implementation of the prefix sum. The serial version for 100,000,000 numbers completes in a second. If there is a use for numbers in the billions, it would most likely be a very specialized use-case. During this coding challenge, I definitely learned more about how to properly generate random numbers!</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/programming/'>programming</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/openmp/" class="post-tag no-text-decoration" >openmp</a> <a href="/tags/boost/" class="post-tag no-text-decoration" >boost</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Parallel+Implementation+of+Prefix+Sum+-+Kyle+Hurd&url=https%3A%2F%2Fkhurd21.github.io%2Fposts%2Fcpp-parallel-prefix-sum%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Parallel+Implementation+of+Prefix+Sum+-+Kyle+Hurd&u=https%3A%2F%2Fkhurd21.github.io%2Fposts%2Fcpp-parallel-prefix-sum%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fkhurd21.github.io%2Fposts%2Fcpp-parallel-prefix-sum%2F&text=Parallel+Implementation+of+Prefix+Sum+-+Kyle+Hurd" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/cpp-template-project-structure/">Serialization and Separating Declaration and Definition in Header Only Libraries</a><li><a href="/posts/cpp-threads/">Threading in C++</a><li><a href="/posts/cpp-parallel-prefix-sum/">Parallel Implementation of Prefix Sum</a><li><a href="/posts/cpp-cmake-openmp/">Adding Boost and OpenMP Library to CMake Project</a><li><a href="/posts/cpp-exploring-for-loops/">Exploring For Loops in Cpp</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/boost/">boost</a> <a class="post-tag" href="/tags/openmp/">openmp</a> <a class="post-tag" href="/tags/parameterized-tests/">parameterized-tests</a> <a class="post-tag" href="/tags/testing/">testing</a> <a class="post-tag" href="/tags/animals/">animals</a> <a class="post-tag" href="/tags/c/">c#</a> <a class="post-tag" href="/tags/cmake/">cmake</a> <a class="post-tag" href="/tags/first-post/">first-post</a> <a class="post-tag" href="/tags/python/">python</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/cpp-cmake-openmp/"><div class="card-body"> <em class="small" data-ts="1675900800" data-df="ll" > Feb 9, 2023 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Adding Boost and OpenMP Library to CMake Project</h3><div class="text-muted small"><p> Starting around mid-2021, I discovered a website called Project Euler. Project Euler “is a series of challenging mathematical/computer programming problems that will require more than just mathemat...</p></div></div></a></div><div class="card"> <a href="/posts/cpp-exploring-for-loops/"><div class="card-body"> <em class="small" data-ts="1674000000" data-df="ll" > Jan 18, 2023 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Exploring For Loops in Cpp</h3><div class="text-muted small"><p> This week I was diving into some of the new features C++ has regarding iteration. This newfound interest stemmed from wanting to make cleaner, more understandable code. There have been many situati...</p></div></div></a></div><div class="card"> <a href="/posts/cpp-threads/"><div class="card-body"> <em class="small" data-ts="1684886400" data-df="ll" > May 24, 2023 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Threading in C++</h3><div class="text-muted small"><p> This post stems from my recent exposure to handling asynchronous functions in other programming languages. One of my recent projects I have dove into is an Alexa Skill called SkyBro. In this projec...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/cpp-cmake-openmp/" class="btn btn-outline-primary" prompt="Older"><p>Adding Boost and OpenMP Library to CMake Project</p></a> <a href="/posts/cpp-threads/" class="btn btn-outline-primary" prompt="Newer"><p>Threading in C++</p></a></div></div></div><div class="footer-right"> <br><p class="mb-0"></p></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/boost/">boost</a> <a class="post-tag" href="/tags/openmp/">openmp</a> <a class="post-tag" href="/tags/parameterized-tests/">parameterized-tests</a> <a class="post-tag" href="/tags/testing/">testing</a> <a class="post-tag" href="/tags/animals/">animals</a> <a class="post-tag" href="/tags/c/">c#</a> <a class="post-tag" href="/tags/cmake/">cmake</a> <a class="post-tag" href="/tags/first-post/">first-post</a> <a class="post-tag" href="/tags/python/">python</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
