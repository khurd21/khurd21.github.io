[ { "title": "Serialization and Separating Declaration and Definition in Header Only Libraries", "url": "/posts/cpp-template-project-structure/", "categories": "programming", "tags": "cpp", "date": "2023-09-06 00:00:00 +0000", "snippet": "In my personal projects, and at work, I have been venturing very heavily into templated libraries.Sometimes the project was completely header-only, other times it was a hybrid. In my most recent endeavor,I was challenged with creating a templated library that was “closed” off from additional implementations.These challenges pressured me into understanding the purpose of certain design patterns and howlarger projects, like Boost, utilized them to build incredible libraries. In this post, I am goingto walkthrough three design-ideas to approaching header-only libraries and discuss their pros and cons.1. Header Only (Literally)The first C++ structured project I learned was separation of declaration and definition. That is,use the .hpp files to store declarations only. A statement saying “I promise this definition willbe available, eventually, when compiling.” In the following example, I am going to walk through a designdecision for serializing and deserializing JSON into a C++ object. When first addressing this problem,I decided to write code similar to the following:IParsable.hpp#ifndef I_PARSABLE_HPP#define I_PARSABLE_HPP#include &lt;string&gt;class IParsable { virtual void serialize(std::ostream&amp; os) = 0; virtual void deserialize(std::istream&amp; is) = 0;}; // class IParsable#endif // I_PARSABLE_HPPUser.hpp#ifndef USER_HPP#define USER_HPP#include &lt;IParsable.hpp&gt;class User : public IParsable {public: std::string UserId; std::string FirstName; std::string LastName; int Age; void serialize(std::ostream&amp; os) const override { // TODO: Add serialize() functionality here } void deserialize(std::istream&amp; is) override { // TODO: Add deserialize() functionality here }}; // class User#endif // USER_HPPThis implementation works and is a viable solution and takes on a very object oriented approach. It is simpleand modular. There is a way we handle it though that I find not ideal. We have to create an instance of the objectbefore we can use the serialize and deserialize methods. This means we have to make an empty object initially andthen load in data into it. Additionally, the functionality of serialize and deserialize never change betweenobjects, or are not instance specific.#include &lt;memory&gt;#include &lt;iostream&gt;const std::string&amp; input = read_json_from_file(\"User.json\");auto user = std::make_unique&lt;User&gt;();user-&gt;deserialize(input);std::cout &lt;&lt; \"UserID: \" &lt;&lt; user-&gt;UserId &lt;&lt; \"\\nAge: \" &lt;&lt; user-&gt;Age &lt;&lt; '\\n';std::istream is;user-&gt;serialize(is);One solution to keep this approach is to simply create a wrapper around the serialization and deserialization methods.ParsableFactory.hpptemplate &lt;typename Parsable&gt;class ParsableFactory {public: static_assert(std::is_base_of&lt;IParsable, Parsable&gt;::value, \"Parsable must be derived from IParsable\"); static std::unique_ptr&lt;Parsable&gt; deserialize(std::istream&amp; is) { std::unique_ptr&lt;Parsable&gt; result = std::make_unique&lt;Parsable&gt;(); result-&gt;deserialize(is); return result; } static void serialize(const Parsable&amp; parsable, std::ostream&amp; os) { parsable.serialize(os); }}; // class ParsableFactoryIt is a great way to help scale the program for if there are many classes that inherit and implementthe IParsable interface. All interactions can come directly from the ParsableFactory, and if thereis a requirement to enforce this behavior, it is possible to protect the serialize and deserializefunctions in the class and create a friend relationship to the factory.std::istream is(/* serializable string*/);const User user = ParsableFactory&lt;User&gt;::deserialize(is); // OK/* ... */User user;user.serialize(); // Error: protected memberThere is one particular aspect I do not like about this implementation. The primary one is thatthe serialize and deserialize are not reliant on a particular instance to be used. And in my head,we should be using deserialize as a means to generate a new IParsable object, not to fill analready existing object. Due to this, there is another way we can enforce having this functionalitywhile also keeping the function members static.template &lt;typename Object&gt;class IParsable { static std::string serialize(const Object&amp; object) { return Object::serialize_internal(object); } static Object deserialize(const std::string&amp; input) { return Object::deserialize_internal(input); }}; // class IParsableThe new IParsable is acting like the ParsableFactory while also enforcing that a staticimplementation of deserialize_internal and serialize_internal be implemented in theinheriting class. The new User class would then look like:class User : public IParsable&lt;User&gt; {public: std::string UserId; std::string FirstName; std::string LastName; int Age;protected: friend IParsable; static std::string serialize_internal(const User&amp; object) { // Add serialize here return {}; } static User deserialize_internal(const std::string&amp; input) { // Add deserialize here return {}; }}; // class UserAlthough it is almost identical, I prefer this one a lot more. Theway you utilize any of the serialize or deserialize functions is a bit different, notrequiring the user to understand which classes support the IParsable interface, which theywould typically find out during compile time from the assert statements. This way,we can get function suggestions straight from the class we want to parse:const std::string input = /* read in content */;const User user = User::deserialize(input);For the rest of this post, I am going to be using the static member function approach.Throughout this, I was writing assuming everything was being placed in the header files.Which leads me to a second and my preferred way to writing quality C++ code with template andnon-template functions.2. Separate Declaration and DefinitionWhen it comes to templated classes and functions, we really do not have a choice but toput them in the header. But that doesn’t mean the definition has to be baked inwith the header declarations. Taking a look at the Boost Library,they separate their implementation by placing the definitions in an .ipp file usually ina impl folder. The i stands for inline, as all definitions in it need to be inlined. We canutilize this approach to separate the implementation in the IParsable file:IParsable.hpp#ifndef IPARSABLE_HPP#define IPARSABLE_HPP#include &lt;string&gt;template &lt;typename Object&gt;class IParsable { static std::string serialize(const Object&amp; object); static Object deserialize(const std::string&amp; input);}; // class IParsable#include &lt;ProjectName/impl/IParsable.ipp&gt;#endif // IPARSABLE_HPPimpl/IParsable.ipp#ifndef IPARSABLE_IPP#define IPARSABLE_IPP#include &lt;string&gt;#include &lt;ProjectName/IParsable.hpp&gt;template &lt;typename Object&gt;std::string IParsable&lt;Object&gt;::serialize(const Object&amp; object) { return {};}template &lt;typename Object&gt;Object IParsable&lt;Object&gt;::deserialize(const std::string&amp; input) { return {};}#endif // IPARSABLE_IPPThe goal is to create a impl folder and place the IParsable.ipp inside of it.Then, at the very bottom of the header file, include IParsable.ipp. As long as theyare templated or inlined, then this separation will work just fine. I tend toonly use the .ipp if there are templated functions being used. Anything that doesn’t haveto be used in the header can go into the .cpp files as usual.3. “Closing” off the templated functionsOne concern that many people have with templated functions is that we leave any user open topass anything and implement anything for the template. There are ways to help avoid this ifthis is not wanted. One method that I found was to instead of include the .ipp file at the bottomof the header, to include it in the .cpp file and then specialize the template for each typeyou want supported.IParsable.cpp#include &lt;ProjectName/impl/IParsable.ipp&gt;#include &lt;ProjectName/User.hpp&gt;IParsable&lt;User&gt;;Now there are only specializations for the User class. If you want to addmore for other classes, simply add the specialization in the .cpp file." }, { "title": "Threading in C++", "url": "/posts/cpp-threads/", "categories": "programming", "tags": "cpp", "date": "2023-05-24 00:00:00 +0000", "snippet": "This post stems from my recent exposure to handling asynchronous functions in otherprogramming languages. One of my recent projects I have dove into isan Alexa Skill called SkyBro. In this project,I used dependencies such as DynamoDB and other APIs that ate up precious time to deliveringa meaningful message back to a user. In order to speed up the Alexa Skill, writing asynchronouscode to gather the needed information became necessary.I rather enjoyed writing asynchronous code. Also, knowing how strange C++ can be, Idecided it would be worthwhile to see how asynchronous code could look in the language.I discovered it is fairly simple to set up. Here is the scenario I built:C++ Async ExampleIn this example, I used the following libraries and using statements:#include &lt;iostream&gt;#include &lt;chrono&gt;#include &lt;thread&gt;#include &lt;future&gt;#include &lt;boost/timer/timer.hpp&gt;using boost::timer::auto_cpu_timer;Let’s say we have a function called foo and another called bar.int foo() { // Perform some time-consuming task std::this_thread::sleep_for(std::chrono::seconds(2)); return 42;}std::string bar() { // Perform some time-consuming task std::this_thread::sleep_for(std::chrono::seconds(3)); return \"Hello, world!\";}Looking at the implementation of the two functions, although very trivial, we can see thatthey are both unrelated to each other and also can take 2-3 seconds to return there result.These two functions are great candidates to be run asynchronously! When I try to see if a functionis worth being run asynchronously, I typically look at the following criteria as a start: Is the function computationally heavy? Are there any other blockers that would prohibit the function fromcompleting its computation? Are there multiple items that have to be computed before the program can continue?In the foo and bar functions above, I am assuming both are computationally heavy. They takeseveral seconds to complete, and because there are more than one, this length becomesmore noticeable. There also aren’t any blockers or dependencies the functions depend on.Serial ExampleIf we run these two functions serially, it’ll take 5 seconds to complete.Codevoid example_sync() { auto_cpu_timer t; // Get function 1 and 2 results when called const auto result_foo{ foo() }; const auto result_bar{ bar() }; // Do something std::cout &lt;&lt; \"Performing other tasks....\\n\"; // Use the results std::cout &lt;&lt; \"Function 1 result: \" &lt;&lt; result_foo &lt;&lt; std::endl; std::cout &lt;&lt; \"Function 2 result: \" &lt;&lt; result_bar &lt;&lt; std::endl; std::cout &lt;&lt; \"Exiting example sync....\\n\";}ResultStarting example sync....Performing other tasks....Function 1 result: 42Function 2 result: Hello, world!Exiting example sync.... 5.010203s wall, 0.000000s user + 0.000000s system = 0.000000s CPU (n/a%)Asynchronous ExampleThe async example is fairly similar, with the added section of starting the tasks and thenwaiting for their results when needed. Note the time to complete is 3 seconds which is thelongest computation coming from the bar function. This highlights that running codeasynchronously is only as fast as the slowest function. If there are many functions being runat the same time, you could come across other constraints that can slow down the functioncompletions.Codevoid example_async() { auto_cpu_timer t; std::cout &lt;&lt; \"Starting example async....\\n\"; // Start function 1 and 2 asynchronously std::future&lt;int&gt; result1{ std::async(std::launch::async, foo) }; std::future&lt;std::string&gt; result2{ std::async(std::launch::async, bar) }; // Do some other work while functions are running... std::cout &lt;&lt; \"Performing tasks while functions are running....\\n\"; // Retrieve the results const auto result_foo{ result1.get() }; const auto result_bar{ result2.get() }; // Use the results std::cout &lt;&lt; \"Function 1 result: \" &lt;&lt; result_foo &lt;&lt; std::endl; std::cout &lt;&lt; \"Function 2 result: \" &lt;&lt; result_bar &lt;&lt; std::endl; std::cout &lt;&lt; \"Exiting example async....\\n\";}ResultStarting example async....Performing tasks while functions are running....Function 1 result: 42Function 2 result: Hello, world!Exiting example async.... 3.005110s wall, 0.000000s user + 0.000000s system = 0.000000s CPU (n/a%)Future DiscussionsAlthough this is a great functionality, and the async operations are relatively simple to read,for me coming from C#, this structure seems like it could be fairly simple to accidentallycreate a blocking operation. I think I much prefer the use of declaring async in the functionheader the way Python or C# do. Although, it does look like C++20 has a similar feature thatgets closer to this called coroutines.This does not look as simple as how other languages handle things. I found another site thatdiscusses coroutines in much depth here." }, { "title": "Parallel Implementation of Prefix Sum", "url": "/posts/cpp-parallel-prefix-sum/", "categories": "programming", "tags": "cpp, openmp, boost", "date": "2023-03-02 00:00:00 +0000", "snippet": "For a while, I have been invested in learning how to parallelize certain algorithms.Parallelizing algorithms and code in general can be tricky. I have discovered that it is quite tricky.It is surprisingly easy to create race conditions, and race conditions could go unnoticed for a longtime or deliver unreliable outputs.Prefix Sum - SerialI was grinding LeetCode questions and Project Euler questions when I came across a problem that requiredthe use of a prefix sum. A prefix sum looks like the following example:a = [ a0, a1, a2, a3 ]p = [ a0, a0 + a1, a0 + a1 + a2 ]p_n = a0 + a1 + ... + an# ORp_n = p_n-1 + anPrefix sum is the running total of all numbers that occurred before it. It carries a dependency on theprevious elements being calculated before future values can be calculated. Here is a serial implementation.Timing the program with an array of size 100’000’000, it only takes around a second to complete. In fact,generating the random array took about 7x longer to populate.#include &lt;vector&gt;#include &lt;random&gt;#include &lt;boost/timer/timer.hpp&gt;using boost::timer::auto_cpu_timer;template &lt;typename T&gt;std::vector&lt;T&gt; prefix_sum_serial(const std::vector&lt;T&gt;&amp; input) { auto_cpu_timer t; if (input.size() == 0) { return {}; } std::vector&lt;T&gt; result(input.size()); result[0] = input[0]; for (int i = 1; i &lt; input.size(); ++i) { result[i] = result[i - 1] + input[i]; } return result;}template &lt;typename T&gt;std::vector&lt;T&gt; generate_random_array(const T lo, const T hi, const std::size_t size) { auto_cpu_timer t; std::random_device random_device; std::mt19937 random_engine(random_device()); std::uniform_int_distribution&lt;T&gt; distribution(lo, hi); std::vector&lt;T&gt; numbers(size); for (size_t i = 0; i &lt; numbers.size(); ++i) { numbers[i] = distribution(random_engine); } return numbers;}int main() { auto_cpu_timer t; const std::uint32_t lo(0); const std::uint32_t hi(999); const std::uint32_t size(100'000'000); const std::vector&lt;std::uint32_t&gt; input_array{ generate_random_array(lo, hi, size) }; const std::vector&lt;std::uint32_t&gt; serial{ prefix_sum_serial(input_array) };}The timer shows that the prefix_sum_serial function finished executing in around 1 second, whereasthe main function took around 7 seconds to complete. Generating the array of random elements took around4.7 seconds.❯ /Users/kylehurd/Workplace/tmp/build/tmp 4.705747s wall, 4.560000s user + 0.130000s system = 4.690000s CPU (99.7%) 1.107477s wall, 1.030000s user + 0.080000s system = 1.110000s CPU (100.2%) 6.956303s wall, 6.720000s user + 0.230000s system = 6.950000s CPU (99.9%)Generate Array of Random Numbers - ParallelGiven this information, parallelizing the prefix sum right now would not yield a large improvement due to thegenerate_random_array function taking the majority of the runtime. My initial thought was to simply parallelize thefor loop in the random array generation function. This actually decrease performance by about 0.2 seconds.I attempted to increase/decrease the block size, make the scheduling dynamic, but all attempts yielded asimilar performance. I could not understand why this was occurring, but my guess was the distribution methodin C++ either didn’t support parallel functionality or the compiler could not figure out a way to parallelize the code.I designed this function to replace the serial version. It uses the simple std::srand function and performsmuch faster.template &lt;typename T&gt;std::vector&lt;T&gt; generate_random_array_parallel(const T lo, const T hi, const std::size_t size) { auto_cpu_timer t; std::srand(std::time(nullptr)); std::vector&lt;T&gt; numbers(size); #pragma omp parallel for for (size_t i = 0; i &lt; numbers.size(); ++i) { numbers[i] = lo + std::rand() % hi; } return numbers;}Generating an array of random elements now completes in under a second. Do note that the linestd::srand(std::time(nullptr)) should exist in main. Also, although I am using this formy needs to showcase the prefix sum, I would prefer to find a way to speed up or improve thefirst implementation of this function. I am not convinced that this implementation is thread-safe,and believe to make things more random, especially across threads, it may be necessary tohave an engine per thread and not share them.❯ /Users/kylehurd/Workplace/tmp/build/tmp 0.728291s wall, 1.780000s user + 0.090000s system = 1.870000s CPU (256.8%)Final ImplementationIn my final attempt at generating a more proper parallel version, I came up with the below implementation.Since there isn’t really a way to guarantee the engine is thread safe, I opted tocreate an engine for each thread. It is almost twice as slow as the previous idea, but I believethis one is actually thread-safe, and is more C++-like. Now onto the actual prefix sum!template &lt;typename T&gt;std::vector&lt;T&gt; generate_random_array_parallel(const T lo, const T hi, const std::size_t size) { auto_cpu_timer t; static std::random_device random_device; static std::vector&lt;std::mt19937&gt; engines(omp_get_max_threads(), std::mt19937(random_device())); std::vector&lt;T&gt; numbers(size); #pragma omp parallel { const int thread_num{ omp_get_thread_num() }; std::uniform_int_distribution&lt;T&gt; distribution(lo, hi); #pragma omp for for (std::size_t i = 0; i &lt; numbers.size(); ++i) { numbers[i] = distribution(engines[thread_num]); } } return numbers;}Prefix Sum - ParallelThe parallel version of the prefix sum consists of two passes called an upsweep and a downsweep.Up SweepIn the up sweep portion, it is needed to build a binary tree such that: The root is a sum between [x,y) If a node has a sum [lo,hi) and hi &gt; lo Left child sum is [lo, middle) Right child sum is [middle, hi) A leaf has a sum of [i, i + 1) This approach is known as divide and conquer. It can be constructed in a parallel fashion.template &lt;typename T&gt;static void upsweep_parallel(const std::vector&lt;T&gt;&amp; input, std::vector&lt;std::vector&lt;T&gt;&gt;&amp; tree) { #pragma omp parallel for for (std::size_t i = 0; i &lt; input.size(); ++i) { tree[0][i] = input[i]; } for (int h = 1; h &lt; tree.size(); ++h) { const int i_end(n / std::pow(2, h)); #pragma omp parallel for for (int i = 0; i &lt; i_end; ++i) { tree[h][i] = tree[h - 1][i &lt;&lt; 1] + tree[h - 1][(i &lt;&lt; 1) + 1]; } } return;}Down SweepThe down sweep is another divide and conquer approach and is relatively straightforward toparallelize. Root is given a left value of 0 Given a left value Pass the left child the left value of the current node Pass the right child the left value of the current node plus the left child’s sum For a given position i output[i] = left + input[i] template &lt;typename T&gt;static void downsweep_parallel(std::vector&lt;T&gt;&amp; input, std::vector&lt;std::vector&lt;T&gt;&gt;&amp; tree1, std::vector&lt;std::vector&lt;T&gt;&gt;&amp; tree2) { tree2[tree2.size() - 1][0] = 0; for (int h = tree1.size() - 2; h &gt;= 0; --h) { const int i_end(std::ceil(input.size() / std::pow(2, h))); #pragma omp parallel for for (int i = 0; i &lt; i_end; ++i) { tree2[h][i] = i % 2 == 0 ? tree2[h + 1][i &gt;&gt; 1] : tree2[h + 1][(i - 1) &gt;&gt; 1] + tree1[h][i - 1]; } } for (std::size_t i = 0; i &lt; input.size(); ++i) { input[i] += tree2[0][i]; } return;}Combine Up Sweep and Down SweepThe result is this:template &lt;typename T&gt;std::vector&lt;T&gt; prefix_sum_parallel(const std::vector&lt;T&gt;&amp; input) { auto_cpu_timer t; if (input.size() == 0) { return {}; } const std::size_t size_of_trees(1 + std::ceil(std::log(input.size() / std::log(2)))); std::vector&lt;T&gt; result(input.size()); std::vector&lt;std::vector&lt;T&gt;&gt; tree1(size_of_trees, std::vector&lt;T&gt;(input.size())); std::vector&lt;std::vector&lt;T&gt;&gt; tree2(size_of_trees, std::vector&lt;T&gt;(input.size())); upsweep_parallel(input, tree1); downsweep_parallel(result, tree1, tree2); return result;}ConclusionThe primary limitation to this design is memory. The larger the array, the more memoryis required. Which almost defeats the purpose of parallelizing the algorithm. The reality is,at a certain point, memory and overhead gets in the way, making the parallel version nofaster than the serial version. But it is a fun exercise to bang your head on for days.I sure had fun!In my eyes, I do not see much benefit from the parallel implementation of the prefix sum.The serial version for 100,000,000 numbers completes in a second. If there is a use fornumbers in the billions, it would most likely be a very specialized use-case. During thiscoding challenge, I definitely learned more about how to properly generate random numbers!" }, { "title": "Adding Boost and OpenMP Library to CMake Project", "url": "/posts/cpp-cmake-openmp/", "categories": "programming", "tags": "cpp, cmake, boost, openmp", "date": "2023-02-09 00:00:00 +0000", "snippet": "Starting around mid-2021, I discovered a website called Project Euler.Project Euler “is a series of challenging mathematical/computer programming problems that will require morethan just mathematical insights to solve.” The questions tend to take me 30 minutes to several hours to come up with a reasonablesolution to get the answer. The website encourages that users implement solutions that run in under a minute.This drove me to consider tools that help speed up the runtime of the program likeOpenMP. Other questions generatedresults that exceeded the storage of 64 bit variables, which made me consider other tools such ascpp_int to solve them.In my first attempt at using these tools, I did not utilize a build manager like cmake or boost-build. I relied oncompiling with just the gcc compiler, and had to add links to the libraries I wanted to include. This was fine forsolving Project Euler questions, however as I solved more problems I struggled to remember what was needed to properlycompile each question. Additionally, from transitioning from a Mac with an Intel processor to the new ARM processor, theoriginal set up I had no longer functioned. It was becoming tedious to program, so I elected to figure out how to usecmake to include the Boost library and OpenMP into my project.Compiler ChoiceWow. Compilers are finicky. I have always used gcc to compile my code. However, when trying to make a workableenvironment, I discovered gcc for the tools I was introducing was not the best choice for developing. It would bepossible, but it would require a lot more steps that I was unwilling to take. I will describe the problems Ifaced below, but for now I decided to use the Homebrew version of Clang++.I used homebrew to download the Boost library. However, this library was compiled using Clang. It was possible torecompile using the gcc compiler instead, but this ended up breaking other tools that relied on Boost. In order tocontinue to use GCC, I would have needed to have to compilations of the library: one using Clang, the other using GCC.I did not want to manage this, so I opted to switch to Clang.The final issue, Apple’s Clang does not support OpenMP. This led me to finally choosing the Homebrew’s Clang. This versionis compatible with the brew installation of Boost and also with OpenMP.╰─❯ brew install llvmThis was the only installation I needed to get this compiler. As for using this compiler in cmake, I added these twosetter commands to the CMakeLists.txt.set(CMAKE_CXX_COMPILER &lt;PATH_TO_CXX_COMPILER&gt;)set(CMAKE_C_COMPILER &lt;PATH_TO_C_COMPILER&gt;)To find the path to the clang compiler, I ran the following commands:❯ brew info llvm==&gt; llvm: stable 15.0.7 (bottled), HEAD [keg-only]Next-gen compiler infrastructurehttps://llvm.org//opt/homebrew/Cellar/llvm/15.0.7_1 (6,411 files, 1.3GB) Poured from bottle on 2023-02-04 at 20:59:32From: https://github.com/Homebrew/homebrew-core/blob/HEAD/Formula/llvm.rbLicense: Apache-2.0 with LLVM-exception==&gt; DependenciesBuild: cmake ✔, swig ✘Required: python@3.11 ✔, six ✔, z3 ✔, zstd ✔### ... Redacted ... ###In my case, the two compilers existed in these directories:/opt/homebrew/opt/llvm/bin/clang++/opt/homebrew/opt/llvm/bin/clangBoostBoost was relatively simple to install on MacOS. Here is the command:╰─❯ brew install boost❯ brew info boost==&gt; boost: stable 1.81.0 (bottled), HEADCollection of portable C++ source librarieshttps://www.boost.org//opt/homebrew/Cellar/boost/1.81.0_1 (15,831 files, 481.6MB) * Poured from bottle on 2023-02-04 at 21:01:32From: https://github.com/Homebrew/homebrew-core/blob/HEAD/Formula/boost.rbWhen using the Homebrew version of the Clang compiler, this should be a simple onboarding process to a project.It is important when running the find_package command that you include the components required for thespecific project. In my case, I have only been relying on Boost::timer. More information can be foundhere.For Project Euler, these two lines satisfied my needs.find_package(Boost 1.81 REQUIRED COMPONENTS timer)target_link_libraries(${PROJECT_NAME} PRIVATE Boost::timer)OpenMPFor OpenMP, it may or may not be required to have this installation:brew install libompThis was a strange problem to solve. When I ran the program without searching for the OpenMP library,Clang gave zero complaints about running, even though the library could not be found. However, CMake deliversa nice message indicating which libraries were found and which ones were not.For adding OpenMP to my project, it turns out all I need after the Homebrew install is to add the following linesin the CMakeLists.txt file.find_package(OpenMP)if (OpenMP_CXX_FOUND) target_link_libraries(${PROJECT_NAME} PUBLIC OpenMP::OpenMP_CXX)endif()CMake FileThe end result of this led to a CMake file that looks like the one below.It is relatively simple, and was just added to speed up my development and to standardize how I run eachproject euler question. Using CMake also helped my ability to diagnose problems a lot faster thanrelying on the error or warning messages from the compiler. In addition to Clang giving very meaningfulalerts in the terminal window, CMake is able to integrate with my favorite code editor, VSCode, givinghelpful information after building the project.For the add_executable, I simply change the file name for the specific question I am attempting to answeror simply wish to review.cmake_minimum_required(VERSION 3.25)set(CMAKE_CXX_STANDARD 20)set(Boost_USE_STATIC_LIBS OFF)set(Boost_USE_MULTITHREADED ON)set(Boost_USE_STATIC_RUNTIME OFF)set(CMAKE_CXX_COMPILER /opt/homebrew/opt/llvm/bin/clang++)set(CMAKE_C_COMPILER /opt/homebrew/opt/llvm/bin/clang)project(project-euler)add_executable(${PROJECT_NAME} 31-40/31.cpp)find_package(Boost 1.81 REQUIRED COMPONENTS timer)find_package(OpenMP)if (OpenMP_CXX_FOUND) target_link_libraries(${PROJECT_NAME} PUBLIC OpenMP::OpenMP_CXX)endif()target_link_libraries(${PROJECT_NAME} PRIVATE Boost::timer)ConclusionIn conclusion, I should have dove into CMake a long time ago. Although I feel like interacting with codeat a terminal level is really important and helped me considerably in learning new languages such as C/C++, buildtools like CMake really help the programmer fret less about nitty-gritty technical details that don’t necessarilytarget what it is you are trying to accomplish. At the end of the day, I was trying to get better at algorithmsand mathematics and the tools I was using was limiting how quickly I could I could get better at those. Plus, you arestill able to communicate with CMake at the terminal shell level! I also think tools such as Boost and OpenMP areimportant to have in a programmers skill set, and using CMake to more easily incorporate them into a project allowsdevelopers to use them with less headache and setup!" }, { "title": "Exploring For Loops in Cpp", "url": "/posts/cpp-exploring-for-loops/", "categories": "programming", "tags": "cpp", "date": "2023-01-18 00:00:00 +0000", "snippet": "This week I was diving into some of the new features C++ has regarding iteration.This newfound interest stemmed from wanting to make cleaner, more understandablecode. There have been many situations when doing LeetCode problems or personalprojects where I felt like I could clean up or use more modern tools in certainsituations. In this post, I will explore some new ways for iterating for loops. Iam using C++20.Basic IterationWe all are familiar with the generic for loop like this:#include &lt;iostream&gt;for (int i{ 0 }; i &lt; 5; ++i) { std::cout &lt;&lt; i &lt;&lt; ',';}❯ /Users/kylehurd/Workplace/tmp/build/for-loops0,1,2,3,4,The above for loop will display to stdout the values from 0-4. For me, I do seetwo issues that have always bugged me (like my joke?). The first is, for each iteration, we may wantto ensure that the value of i does not update within the for loop itself. With thisimplementation there is not a good way to do this. The second is it doesn’tlook clean to me. Surely there can be a better way to use an iterator.As I did some digging, I found a new function in the C++20 standard calledstd::views::iota.We can use that function to help try and clean up the for loop. In a basic setting,it works very similarly to a range for loopin Python. The first argument is the starting position and the second argument is the endingposition. The start is inclusive where as the end is exclusive. [start, end)for (const int i : std::views::iota(0, 5)) { std::cout &lt;&lt; i &lt;&lt; ',';}I personally find this easier to read, although the implementation is actually a bit lengthiercompared to the generic for loop. Plus, our iterator i is now a const type. There are otherreasons why this type of for loop would be ideal over the generic version. For example, if youwanted to filter the iterations by odd numbers only you can add a filter option:auto odd = [](const int value) { return value % 2 == 1; };for (const int i : std::views::iota(0,10) | std::views::filter(odd)) { std::cout &lt;&lt; i &lt;&lt; ',';}❯ /Users/kylehurd/Workplace/tmp/build/for-loops1,3,5,7,9,There are much more modifications you can make within the std::views namespace. You can checkthem out in the Microsoft Documentation.Container IterationFor this section, I focused on different ways you can iterate over containers. We can filter,transform, and perform other operations on the container in the same way as above. For example,given a std::vector object, we can do the following:#include &lt;vector&gt;// ...std::vector&lt;int&gt; v { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };const auto odd = [](const int number) { return number % 2 == 1; };for (const int value : v | std::views::filter(odd)) { std::cout &lt;&lt; value &lt;&lt; ',';}std::cout &lt;&lt; std::endl;❯ /Users/kylehurd/Workplace/tmp/build/for-loops1,3,5,7,9,Shifting over to a different type, consider the following situation. Below we have an unorderedmap containing a string as the key and float as the value. The key is the store that wasvisited and the value is the amount spent at said store.std::unordered_map&lt;std::string, float&gt; transactions;transactions.insert_or_assign(\"Safeway\", 1.97);transactions.insert_or_assign(\"Walmart\", 18.81);transactions.insert_or_assign(\"Apple\", 119.03);transactions.insert_or_assign(\"Sears\", 32.43);Given this map, if we wanted to iterate over each item and print each item, we could do this:for (const auto&amp; transaction : transactions) { std::cout &lt;&lt; transaction.first &lt;&lt; \": $\" &lt;&lt; transaction.second &lt;&lt; '\\n';}// or we could utilize a lambdaconst auto print_transaction = [](const auto&amp; node) { std::cout &lt;&lt; node.first &lt;&lt; \": $\" &lt;&lt; node.second &lt;&lt; '\\n';};for (const auto&amp; transaction : transactions) { print_transaction(transaction)}The lambda helps the for loop become slightly more readable, but I do not like the variables .firstand .second. To me, they make it unclear what first and second are. There is another way we caniterate over a pair object like this by unpacking the map before entering the for loop. This isone of my favorite ways to iterate over these types of objects at the moment. It allows us togive better names to our variables before entering the loop.#include &lt;format&gt;// ...for (const auto&amp; [store, cost] : transactions) { // gcc-13 std::cout &lt;&lt; std::format(\"{}: ${}\\n\", store, cost); // gcc-12 std::cout &lt;&lt; store &lt;&lt; \": $\" &lt;&lt; cost &lt;&lt; '\\n';}That’s my rundown on a few different ways to iterate! There are a lot of cool features released in C++20and a lot of it helps improve readability of a program." }, { "title": "Parameterized Unit Tests in Python", "url": "/posts/python-parameterized-tests/", "categories": "programming", "tags": "python, testing, parameterized-tests", "date": "2022-09-13 00:00:00 +0000", "snippet": "In a previous blog post, I covered how to write parameterized testsin C#. To me, C# test cases are easier to write than Python test cases.I think this is due to the fact that C# has a lot of test features builtinto the language. In the case of parameterized tests, Python needs touse a third-party library to achieve the same result. The two popularlibraries to achieve this right now arepytestandparameterized.For this post, I will be using the parameterized library in conjunctionwith the unittest library already built into Python.I searched for a while to find an equivalent to the C#TestCaseDataclass for Python, but could not find one. This would honestly be agreat addition to the parameterized library, as it gave me a differentperspective on how I can approach writing tests. It also seems like a greatway to separate data from the test cases themselves.Python Parameterized TestsFor this example, I made a quick Python class that contains functions to determineif a string is title and to make a string a title if it is not already. Theimplementation is not important for this post, and I will provide a fewexamples of what some expected results should be.# validator.pyclass TitleExpressionValidator: _excluded_words_to_capitalize = ['of', 'the', 'a', 'an'] def is_valid(self, title_expression: str): if title_expression is None or len(title_expression) == 0: return False if title_expression[0].islower(): return False all_words = title_expression.split()[1:] potential_uppercase_words = list(filter(lambda word: len(word) &gt; 3, all_words)) potential_lowercase_words = list(filter(lambda word: len(word) &lt;= 3 and word in self._excluded_words_to_capitalize, all_words)) return all(map(lambda word: word[0].isupper(), potential_uppercase_words)) and \\ all(map(lambda word: word[0].islower(), potential_lowercase_words)) def make_title(self, title_expression: str): if title_expression is None or len(title_expression) == 0: raise ValueError('title_expression cannot be None or empty') words = title_expression.split() first_word = words[0].capitalize() rest_words = words[1:] return f'{first_word} {\" \".join(map(lambda word: word.capitalize() if word not in self._excluded_words_to_capitalize else word.lower(), rest_words))}'Expected Results Input is_valid output make_title output The Lord of the Rings True The Lord of the Rings The Little Drummer Boy True The Little Drummer Boy Hello, World! True Hello, World! The lord of the rings False The Lord of the Rings the Little Drummer Boy False The Little Drummer Boy The Little drummer Boy False The Little Drummer Boy Set Up the ProjectIn a directory for this project, all you’ll need is two python script files.The validator.py script is the same script that was displayed in theintroduction section of this blog post.|- validator.py|- validator_test.py|- venv/| |- **Additionally, since we are going to install a 3rd party library, let’s set upa virtual environment.python3 -m venv venvsource venv/bin/activatepip3 install parameterizedpip3 freeze &gt; requirements.txtWriting the Test CasesFor the first section, I am going to write tests that focus on the is_validfunction. The trivial approach would be to write a test for each of the expectedresults. Since there are two outputs possible for any given input, this wouldmean we could write two types of tests, one for True and the other for False.The impact of this approach is that we would have to write 12 tests, which isnot scalable when the size of tests grows. Here is an example:Appraoch 1: Write a Test for Each Expected Result# validator_test.pyimport validatorimport unittestimport parameterizedclass ValidatorTest(unittest.TestCase): def setUp(self): self.validator = validator.TitleExpressionValidator() return def test_is_valid_returns_true(self): self.assertTrue(self.validator.is_valid(\"The Lord of the Rings\")) return def test_is_valid_returns_false(self): self.assertFalse(self.validator.is_valid(\"The lord of the rings\")) return # ...Approach 2: Write a Parameterized TestThe first major improvement we can make to this implementation is to introduce theparameterized library and use it reduce the number of test functions we need toimplement down to two. We can parameterize the test cases by using theparameterized.expand decorator.class ValidatorTest(unittest.TestCase): def setUp(self): self.validator = validator.TitleExpressionValidator() return @parameterized.parameterized.expand([ 'The Lord of the Rings', 'The Little Drummer Boy', 'Hello, World!' ]) def test_is_valid_returns_true(self, expression): self.assertTrue(self.validator.is_valid(expression)) @parameterized.parameterized.expand([ 'The lord of the rings', 'the Little Drummer Boy', 'hello, World!' ]) def test_is_valid_returns_false(self, expression): self.assertFalse(self.validator.is_valid(expression)) returnApproach 3: Combining Tests per FunctionThis approach is a lot better. We can now add or remove test cases by simplyadding or removing them from the list. However, I am still not satisfied withthis approach. The problem with this approach is that we are separating thetest case sources based on output. For boolean functions, this is not a bigdeal, but for functions that return other types, say an integer or string,how would we separate the test cases based on the output? Additionally,since the test case sources are separated, it could be easy to overlook or mistakea test case for the wrong test function. My solution to this problem is tocombine the two test functions into one and add a second parameter to theparameterized.expand decorator. This additional parameter can representthe expected output of the test case.class ValidatorTest(unittest.TestCase): def setUp(self): self.validator = validator.TitleExpressionValidator() return @parameterized.parameterized.expand([ ('The Lord of the Rings', True), ('The Little Drummer Boy', True), ('Hello, World!', True), ('The lord of the rings', False), ('the Little Drummer Boy', False), ('The Little drummer Boy', False), ]) def test_is_valid(self, expression, expected): self.assertEqual(self.validator.is_valid(expression), expected) returnApproach 4: Separating Test Sources from Test CasesApproach 3 to me is an ideal solution.However, if the test case sources become too large, it will be difficult toread and maintain the test suite. In situations like this, it would be niceto remove the test case sources from the test function and store them in aseparate file. This approach looks very similar to the approach I took in myprevious blog post on parameterized testing in C#. In this implementation,we can simply take the list of test sources and store them in a generator function.def _validator_responses(): '''yield (&lt;input&gt;, &lt;is_valid expected&gt;, &lt;make_title expected&gt;)''' yield ('The Lord of the Rings', True, 'The Lord of the Rings') yield ('The Little Drummer Boy', True, 'The Little Drummer Boy') yield ('Hello, World!', True, 'Hello, World!') yield ('The lord of the rings', False, 'The Lord of the Rings') yield ('the Little Drummer Boy', False, 'The Little Drummer Boy') yield ('The Little dummer Boy', False, 'The Little Dummer Boy')We can then use this generator to test two functions within TitleExpressionValidator.Separating the test data from the test implementation to me makes it much morereadable.class ValidatorTest(unittest.TestCase): def setUp(self): self.validator = validator.TitleExpressionValidator() return @parameterized.parameterized.expand(_validator_responses) def test_is_valid(self, expression, expected, _): self.assertEqual(self.validator.is_valid(expression), expected) return @parameterized.parameterized.expand(_validator_responses) def test_make_title(self, expression, _, make_title): self.assertEqual(self.validator.make_title(expression), make_title) returnApproach 5: Parameterizing at the Class LevelI added this approach as it was unique. I have not seen this availablein any other testing framework or library. The decorator parameterized_classcan be used to parameterize the test cases at the class level. In this decorator,you can specify the names of the field names that will be used to representthe test case sources. The generator function will then assign the values tothe specified field names to be used in the class. This is a very powerful featurethat we can use to take advantage of the fact that an expression can be passed intoboth is_valid and make_title and produce a valid result.@parameterized.parameterized_class(('expression', 'is_valid', 'make_title'), _validator_responses())class ValidatorTest(unittest.TestCase): def setUp(self): self.validator = validator.TitleExpressionValidator() return def test_is_valid(self): self.assertEqual(self.validator.is_valid(self.expression), self.is_valid) return def test_make_title(self): self.assertEqual(self.validator.make_title(self.expression), self.make_title)" }, { "title": "Parameterized Unit Tests in C#", "url": "/posts/csharp-parameterized-tests/", "categories": "programming", "tags": "c#, testing, parameterized-tests", "date": "2022-09-10 00:00:00 +0000", "snippet": "During one of my classes at university, we covered how to writequality unit tests. I noticed early on that some of the testswere very similar to each other and I often found myselfunnecessarily repeating code or writing tests that weretesting for the same output, but with different inputs. I was notsatisfied with this and eagerly searched for a method toabstract away the repeated code and make my tests morereadable.I found a solution to this problem, and the term for it is“parameterized tests.” This form of testing allows the programmerto write a test that can accept multiple inputs. In this blog, Iwill be covering how one can write parameterized testsin C#. In a future blog I may cover this concept using Python.I find this tool to be very useful and importantto know about when writing unit tests.C# Parameterized TestsIn my example, I will becreating a simple expression validator that will check if astring is a valid mathematical expression. The implementation isnot super important, and I am only using it to demonstrate howto write parameterized tests.Set Up the ProjectTo start, I will create a new C# project using dotnet CLI. I am usingdotnet 6.dotnet new sln -n ExpressionValidatordotnet new classlib -n ExpressionValidatordotnet new nunit -n ExpressionValidator.Testdotnet sln add ExpressionValidatordotnet sln add ExpressionValidator.Testdotnet add ExpressionValidator.Test reference ExpressionValidatordotnet buildCreate the Expression ValidatorGreat! Now that we have a project set up, I am going to create twoExpressionValidator classes. One will be for math formula, and theother will be for confirming an expression is a valid title. The codehere is not important, we are only using it to demonstrate how towrite parameterized tests.Here is the structure:|- ExpressionValidator| |- TitleExpressionValidator.cs| |- IExpressionValidator.cs|- ExpressionValidator.Test| |- TitleExpressionValidatorTest.csSince the validator is going to be testing if an expressionis valid or not, I will create an interface to define theIsValid method.// IExpressionValidator.csnamespace ExpressionValidator;public interface IExpressionValidator{ bool IsValid(in string expression);}Below is the implementation of the IExpressionValidator interface.// TitleExpressionValidator.csnamespace ExpressionValidator;public class TitleExpressionValidator : IExpressionValidator{ public bool IsValid(in string expression) { List&lt;string&gt; words = new(expression.Split(' ')); return words.All(word =&gt; word.Length &gt; 0 &amp;&amp; word[0] == char.ToUpper(word[0])); }}Create the TestsNow let’s write some tests. I will start with with the TitleExpressionValidator tests. The current state of the unit testsare acceptable and they are passing. However, they do not promote extensibility. If I wanted to add more tests for valid scenarios, howwould I do that with the current implementation?// TitleExpressionValidatorTest.csnamespace ExpressionValidator.Test;[TestFixture]public class TitleExpressionValidatorTest{ private IExpressionValidator ExpressionValidator { get; set; } = default!; [SetUp] public void SetUp() { this.ExpressionValidator = new TitleExpressionValidator(); } [Test] public void IsValid_WhenExpressionIsValid_ReturnsTrue() { Assert.IsTrue( this.ExpressionValidator.IsValid(\"Hello, World!\"), message: $\"Expression: `Hello, World!` should be valid.\"); } [Test] public void IsValid_WhenExpressionIsNotValid_ReturnsFalse() { Assert.IsFalse( this.ExpressionValidator.IsValid(\"hello world\"), message: $\"Expression: `hello world` should not be valid.\"); }}❯ dotnet testStarting test execution, please wait...A total of 1 test files matched the specified pattern.Passed! - Failed: 0, Passed: 2, Skipped: 0, Total: 2, Duration: 3 msThe ability to parameterize tests in C# is actually quite simple and very cool.There are two ways to do this. The first way is to use the TestCase attribute.The second way is to use the TestCaseSource attribute. I will be covering bothways in this blog. TestCase is a great way to parameterize tests when thereare not many test cases. If there are a lot of test cases, or if the test casescan be shared between multiple test classes, then TestCaseSource is the wayto go.In the improvement below, we helped make the test cases more readable andmodular. Now adding an additional test case, or removing a test case, isas simple as adding or removing a line of code.[Test][TestCase(\"Hello World\")][TestCase(\"Hello, World!\")][TestCase(\"Greetings, From Mars\")]public void IsValid_WhenExpressionIsValid_ReturnsTrue(in string expression){ Assert.IsTrue( this.ExpressionValidator.IsValid(expression), message: $\"Expression: {expression} should be valid.\");}[Test][TestCase(\"hello world\")][TestCase(\"hello, world!\")][TestCase(\"Greetings, From mars\")]public void IsValid_WhenExpressionIsNotValid_ReturnsFalse(in string expression){ Assert.IsFalse( this.ExpressionValidator.IsValid(expression), message: $\"Expression: {expression} should not be valid.\");}❯ dotnet test Determining projects to restore... Starting test execution, please wait...A total of 1 test files matched the specified pattern.Passed! - Failed: 0, Passed: 6, Skipped: 0, Total: 6, Duration: 4 msFor this example, stopping here seems perfectly fine. However, let’s continueto try and abstract away at the test cases. Let’s say the implementation ofTitleExpressionValidator is much more complex and there are a lot of testscenarios to cover. It would be nice to group the test scenarios togetherif the list of test cases grows. This is where TestCaseSource comes in.I found the cleanest way for me to store the test cases is to create aTestCaseSources class containing all of the test cases for the methodunder test. Once this is done, we can use the TestCaseSource attributeto reference the test cases.// TestCaseSources/ExpressionValidatorTestCaseSources.csnamespace ExpressionValidator.Test.TestCaseSources;public static class ExpressionValidatorTestCaseSources{ public static IEnumerable&lt;TestCaseData&gt; IsValid_WhenExpressionIsValid_ReturnsTrue { get { yield return new TestCaseData(\"Hello World\").Returns(true); yield return new TestCaseData(\"Hello, World!\").Returns(true); yield return new TestCaseData(\"Greetings, From Mars\").Returns(true); } } public static IEnumerable&lt;TestCaseData&gt; IsValid_WhenExpressionIsNotValid_ReturnsFalse { get { yield return new TestCaseData(\"hello world\").Returns(false); yield return new TestCaseData(\"hello, world!\").Returns(false); yield return new TestCaseData(\"Greetings, From mars\").Returns(false); } }}Modified Test Cases:[Test][TestCaseSource( typeof(ExpressionValidatorTestCaseSources), nameof(ExpressionValidatorTestCaseSources.IsValid_WhenExpressionIsValid_ReturnsTrue))]public bool IsValid_WhenExpressionIsValid_ReturnsTrue(in string expression){ return this.ExpressionValidator.IsValid(expression);}[Test][TestCaseSource( typeof(ExpressionValidatorTestCaseSources), nameof(ExpressionValidatorTestCaseSources.IsValid_WhenExpressionIsNotValid_ReturnsFalse))]public bool IsValid_WhenExpressionIsNotValid_ReturnsFalse(in string expression){ return this.ExpressionValidator.IsValid(expression);}❯ dotnet test Determining projects to restore... Starting test execution, please wait...A total of 1 test files matched the specified pattern.Passed! - Failed: 0, Passed: 6, Skipped: 0, Total: 6, Duration: 8 msOptimal SolutionThis new design of utilizing TestCaseSource is a very powerful featurein C#. Looking at the last implementation, we can combine the two testmethods into one. Taking advantage of the TestCaseData class, we candeclare the expected result of the test case.Here is the final product:// TestCaseSources/ExpressionValidatorTestCaseSources.csnamespace ExpressionValidator.Test.TestCaseSources;public static class TitleExpressionValidatorTestCaseSources{ public static IEnumerable&lt;TestCaseData&gt; IsValid { get { yield return new TestCaseData(\"Hello World\").Returns(true); yield return new TestCaseData(\"Hello, World!\").Returns(true); yield return new TestCaseData(\"Greetings, From Mars\").Returns(true); yield return new TestCaseData(\"hello world\").Returns(false); yield return new TestCaseData(\"hello, world!\").Returns(false); yield return new TestCaseData(\"greetings, from mars\").Returns(false); } }}// TitleExpressionValidatorTest.csusing ExpressionValidator.Test.TestCaseSources;namespace ExpressionValidator.Test;[TestFixture]public class TitleExpressionValidatorTest{ private IExpressionValidator ExpressionValidator { get; set; } = default!; [SetUp] public void SetUp() { this.ExpressionValidator = new TitleExpressionValidator(); } [Test] [TestCaseSource(typeof(TitleExpressionValidatorTestCaseSources), nameof(TitleExpressionValidatorTestCaseSources.IsValid))] public bool IsValidTest(in string expression) { return this.ExpressionValidator.IsValid(expression); }}❯ dotnet test Determining projects to restore... Starting test execution, please wait...A total of 1 test files matched the specified pattern.Passed! - Failed: 0, Passed: 6, Skipped: 0, Total: 6, Duration: 7 msAnd there we go. We have improved how we can write our test cases. Learningthese new features of NUnit and how C# handles tests has been a greatlearning opportunity and I hope you enjoyed reading this as much as Ienjoyed writing it." }, { "title": "My First Post", "url": "/posts/my-first-post/", "categories": "general", "tags": "first-post, animals", "date": "2022-09-09 00:00:00 +0000", "snippet": "Greetings, world! This is my first post on my new blog.I’m excited to get started. This post is a test to ensure thateverything is working properly. I’ll be posting more soon. In themean time, here’s a few pictures of my cat, Max. He is an adorablekitty and I try to spoil him every chance I get. He currently liveswith my parents as I am away at college, but I visit him duringmy breaks from school. Max giving his best blep Max soaking up the sun from the sliding glass door Max enjoying a nice dinner " } ]
